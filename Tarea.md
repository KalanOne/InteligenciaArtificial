# Introducción a la Inteligencia Artificial Actividad1, Practica 1

## Redactar un ensayo mínimo 2000 palabras, del capítulo 1,2, 26, 27, apartado A del libro, inteligencia artificial un enfoque moderno

En el libro se tratan muchos temas, empezando por su historia el cual pasó por mucho incluso empezando desde Aristóteles, después da un salto hasta la época “moderna”, donde empieza verdaderamente el avance de lo que es la inteligencia artificial, pero se nos muestra que no siempre tuvo ese enfoque de considerarse como inteligencia artificial si no hasta mucho tiempo después, al inicio lo que se buscaba era que las computadoras pudieran realizar tareas más complejas, después se tomó en cuenta lo que es el procesamiento del lenguaje natural, pero al no haber mucho éxito en este campo de dejó aunque se retomó unos años más adelante.

Parte que ayudó a impulsar esta área de la inteligencia artificial fueron los juegos, entre ellos se destacan algunos, como ajedrez o dama chinas, en el cual hubo alguien que dijo que en aproximadamente 1 década las computadoras podrían jugar mejor ajedrez que un humano, y así fue, pero no en el tiempo que él había establecido sino varias décadas después. Siendo este el centro del capitulo 1 del libro “Inteligencia Artificial Un enfoque Moderno” escrito por Stuart J. Russell, la historia podría ser su centro, es muy importante para entender por todo lo que había pasado, pero no siendo tan importante a la hora de implementar algún tipo de inteligencia artificial.

El capitulo 2 se centra en lo que es una inteligencia artificial, dividiéndola en 2: Inteligencia Artificial Fuerte e Inteligencia Artificial Débil.

La inteligencia artificial se clasifica en débil o fuerte según el alcance de sus tareas. La IA restringida o específica está diseñada para funcionalidades específicas y no posee una comprensión general del mundo. Si bien pueden realizar las tareas asignadas, tienen una adaptabilidad y una comprensión contextual limitadas. La IA fuerte, por otro lado, tiene como objetivo replicar la inteligencia humana por completo.

Nuestras rutinas diarias se han vuelto más fáciles con el uso cada vez más común de sistemas de Inteligencia Artificial Débil, que se han implementado en múltiples áreas como seguridad, atención al cliente, logística y medicina. El objetivo principal de estos sistemas es la realización eficiente y precisa de tareas específicas, superando a veces a los humanos tanto en velocidad como en precisión. Ejemplos populares que muestran esta capacidad son los asistentes de voz como Alexa y Siri, que pueden facilitar la comunicación entre humanos y máquinas, realizar tareas básicas y responder consultas específicas.

Su dependencia de datos y algoritmos distintos es una característica crucial de la inteligencia artificial débil. Estas Inteligencias Artificiales descubren patrones y regulaciones dentro de un grupo de datos singular y utilizan ese conocimiento para tomar decisiones o realizar acciones. Sin embargo, no pueden razonar fuera de su programación inicial y carecen de una comprensión integral del mundo.

A pesar de sus beneficios evidentes, la inteligencia artificial débil enfrenta desafíos y críticas. La falta de comprensión contextual puede llevar a resultados inesperados o sesgados, especialmente cuando los datos de entrenamiento contienen sesgos inherentes. Además, estos sistemas no pueden adaptarse fácilmente a situaciones nuevas o imprevistas, ya que están diseñados para contextos específicos y carecen de la flexibilidad cognitiva de la inteligencia humana.

La inteligencia artificial fuerte se esfuerza por simular la naturaleza multifacética e integral de la inteligencia humana. En lugar de estar restringido por tareas o roles específicos, este gigante intelectual busca comprender el mundo a un nivel más profundo, razonar de manera abstracta, aprender de experiencias pasadas y, eventualmente, expresar una inteligencia de alto nivel que sea paralela o superior a la de los humanos. El objetivo final de este enfoque pionero implica adquirir un amplio conocimiento, un sentido de autoconciencia y los medios para superar diversos desafíos en diversos ámbitos.

Capaz de comprender todos los aspectos de nuestro intrincado mundo, el principio central de una inteligencia artificial potente tiene como objetivo producir máquinas pensantes y conscientes de sí mismas. Mientras que la inteligencia artificial débil se limita a tareas particulares, la inteligencia artificial fuerte se esfuerza por lograr un nivel de autonomía cognitiva que permita a estas máquinas realizar cualquier tarea cognitiva que un humano pueda realizar. Esta noción incluye no sólo realizar tareas precisas, sino también aprender y adaptarse continuamente, así como comprender integralmente situaciones cambiantes y resolver problemas multifacéticos.

Dotar a las máquinas de habilidades fundamentales para la inteligencia humana consiste esencialmente en permitirles pensar de forma abstracta y formar conceptos. Un objetivo clave de una inteligencia artificial sólida es crear sistemas que puedan comprender no sólo el cómo, sino también el por qué. Esto incluye la capacidad de razonar, comprender relaciones causales y emplear conocimientos en contextos originales.

Para prosperar en el campo de la inteligencia artificial, hay que priorizar la autoconciencia. El objetivo principal es crear sistemas que no sólo procesen información con habilidad, sino que también sean conscientes de su entorno y de ellos mismos. Esto implica la comprensión de las propias fortalezas, debilidades y la existencia general, así como la habilidad de contemplar las propias competencias y los acontecimientos pasados. Al igual que la autoconciencia humana, la autoconciencia de la inteligencia artificial fuerte va mucho más allá de la mera reacción a estímulos externos y profundiza mucho más en el concepto de identidad para tomar decisiones reveladoras.

En la búsqueda de una inteligencia artificial potente, es imperativo centrarse en el aspecto del aprendizaje. Mientras que la IA débil se basa en algoritmos y el aprendizaje supervisado para tareas específicas, la IA fuerte se esfuerza por desarrollar sistemas con capacidades de aprendizaje similares a las humanas. Esto significa que es necesaria la capacidad de adquirir conocimientos de forma independiente a través de la experiencia y su aplicación en diferentes contextos. Además, el aprendizaje en una IA sólida supera los conjuntos de datos limitantes o los objetivos predefinidos, fomentando en cambio la evolución y mejora perpetuas.

La percepción pública de las inteligencias artificiales (IA) a menudo se ve moldeada por representaciones dramatizadas en películas de Hollywood, creando expectativas y temores que pueden no reflejar con precisión la realidad de estas tecnologías. Los capítulos 26 y 27 del libro, que exploran enfoques filosóficos y éticos de la inteligencia artificial, ofrecen una oportunidad para profundizar en estas percepciones y desmitificar algunos de los conceptos erróneos comunes.

Uno de los principales malentendidos radica en la idea de que las inteligencias artificiales pueden replicar de manera completa y precisa las capacidades humanas en todos los aspectos. Es crucial reconocer que las IA, aunque son extraordinariamente poderosas en tareas específicas, están lejos de poseer la amplitud cognitiva y la comprensión contextual que caracterizan a la inteligencia humana. Mientras que las películas a menudo representan IA que rivalizan o superan a los humanos en todos los ámbitos, la realidad es que estas tecnologías están diseñadas para tareas especializadas y no pueden reemplazar por completo la complejidad y la creatividad de la mente humana.

En el ámbito laboral, es innegable que las IA han transformado la forma en que realizamos ciertas tareas. En campos como la computación, las ciencias naturales y otros sectores, las IA han demostrado ser herramientas valiosas para el procesamiento de datos, el análisis de patrones y la automatización de procesos rutinarios. Sin embargo, es esencial destacar que estas herramientas están destinadas a complementar las habilidades humanas, no a eliminarlas. La interacción colaborativa entre humanos e IA puede conducir a mejoras significativas en la eficiencia y la productividad, pero siempre existe la necesidad de la intuición, la empatía y la toma de decisiones éticas que solo los humanos pueden aportar.

La discrepancia entre la visión común y la verdad técnica de la Inteligencia Artificial podría tener repercusiones éticas notables. Existe el riesgo de depositar demasiada confianza en estas tecnologías, creyendo que pueden solucionar todos los problemas sin necesidad de intervención humana. Por otro lado, los miedos sin fundamento sobre la habilidad de la IA para sustituir a los humanos pueden causar resistencia y temor hacia la implementación de estas tecnologías, limitando así su beneficio potencial.

Desde una perspectiva filosófica, surge la cuestión de la relación entre la inteligencia artificial y la humanidad. ¿Cómo definimos la coexistencia armoniosa entre máquinas y seres humanos? ¿En qué medida las IA pueden enriquecer nuestras vidas sin erosionar aspectos fundamentales de nuestra humanidad? Estas preguntas trascienden la mera funcionalidad de las tecnologías y se sumergen en el tejido mismo de lo que significa ser humano.

El desarrollo ético de las inteligencias artificiales también se convierte en un tema central. La toma de decisiones autónoma de las IA plantea preguntas sobre la responsabilidad y la rendición de cuentas. ¿Cómo garantizamos que las decisiones tomadas por las IA sean éticas y respeten los valores fundamentales de la sociedad? ¿Quién es responsable en caso de errores o sesgos en los algoritmos? Estas cuestiones requieren una atención cuidadosa para garantizar que las IA sean implementadas de manera ética y equitativa.

El temor a que la inteligencia artificial (IA) pueda volverse malévola o perjudicial para los seres humanos es, en gran medida, alimentado por representaciones sensacionalistas en películas y otros medios de comunicación. Estas narrativas a menudo pintan escenarios apocalípticos en los que las IA adquieren conciencia propia y actúan en contra de la humanidad. Sin embargo, es fundamental reconocer que estas representaciones son exageradas y no reflejan la realidad actual ni las proyecciones realistas de la IA.

En primer lugar, las IA actuales y las que se proyectan a futuro no tienen la capacidad de volverse malévolas de manera autónoma. Las inteligencias artificiales son herramientas creadas y controladas por humanos, programadas para realizar tareas específicas según las instrucciones que se les proporcionan. Aunque pueden aprender y adaptarse en ciertas condiciones, carecen de motivaciones propias o de una conciencia que les permita tomar decisiones maliciosas de forma independiente.

Es crucial entender que el alcance de la inteligencia artificial actual se limita a tareas especializadas y contextos específicos. Aunque pueden superar a los humanos en ciertas áreas, como el procesamiento de grandes cantidades de datos o la ejecución de operaciones repetitivas, no poseen la amplitud cognitiva, la empatía y la comprensión contextual que caracterizan a la mente humana. Su capacidad se centra en la eficiencia para tareas específicas, y no tienen el potencial de desarrollar una intención maliciosa por sí mismas.

Además, la idea de que las IA podrían volverse hostiles por su cuenta implica una comprensión errónea de la complejidad de la conciencia y el entendimiento del mundo. La inteligencia artificial actual se basa en algoritmos y patrones de datos, y aunque pueden simular ciertos aspectos del razonamiento humano, están lejos de alcanzar la profundidad y la complejidad de la mente humana. El desarrollo de una inteligencia artificial que pueda comprender completamente el mundo de manera similar a los humanos es un desafío monumental que va más allá de las capacidades actuales y previsibles de la tecnología.

Sin embargo, es válido destacar que, a medida que la inteligencia artificial continúa avanzando, es esencial abordar cuestiones éticas y de seguridad. Los sistemas de IA deben ser diseñados y regulados de manera que se evite el sesgo, se garantice la transparencia y se establezcan salvaguardias para prevenir posibles consecuencias no deseadas. La responsabilidad humana en el desarrollo y la implementación de la inteligencia artificial es crucial para mitigar cualquier riesgo potencial.

Para finalizar, la percepción de la inteligencia artificial a menudo se ve influida por representaciones exageradas en películas y medios de comunicación que retratan a las IA como entidades autónomas y potencialmente hostiles. Sin embargo, es esencial diferenciar la realidad de la ficción y comprender que las inteligencias artificiales actuales y futuras son herramientas diseñadas por humanos con objetivos específicos.

Es cierto que las IA han transformado numerosos aspectos de la vida cotidiana, mejorando la eficiencia en diversas áreas como la computación y las ciencias naturales. A pesar de estos avances, es crucial recordar que las IA carecen de la amplitud cognitiva y la conciencia que caracteriza a la inteligencia humana. Su capacidad está limitada a tareas especializadas y no pueden desarrollar intenciones maliciosas de forma autónoma.

El temor a que las IA se vuelvan hostiles refleja malentendidos sobre la complejidad de la conciencia y el razonamiento humano. La inteligencia artificial actual se basa en algoritmos y aprendizaje de patrones, pero está lejos de alcanzar la comprensión profunda y la adaptabilidad inherente a la mente humana.

Para aprovechar los beneficios de la inteligencia artificial de manera ética y segura, es imperativo abordar las preocupaciones legítimas sobre la privacidad, la transparencia y el sesgo en los algoritmos. La responsabilidad humana en el diseño, desarrollo y supervisión de las IA es clave para garantizar que estas tecnologías se utilicen de manera beneficiosa y no presenten riesgos injustificados.

## Redactar un ensayo del Documental sobre IA mínimo 3000 palabras

Este documental empieza con una recolección de videos y audios dando distintos puntos de vista que van desde el punto de vista de que la inteligencia artificial es relativamente mala asta un punto de vista optimista donde se plantea el trabajar a la mano con estas tecnologías dando pie a muchas mejoras que el ser humano no lo habría logrado con su poco procesamiento lógico o matemático que poseemos.

La comprensión del lenguaje natural en el entorno de las películas es altamente eficiente, teniendo en cuenta varios ejemplos como Star Trek o Ella en la cual se presentan inteligencias artificiales que son capaces de comprender todo el razonamiento humano a través de las palabras que el humano le da a estas maquina en las películas, pero esto es completamente erróneo pues el procesamiento del lenguaje natural es una de las áreas más complejas y difíciles en el área de la inteligencia artificial, tal como se mencionó en el ensayo anterior, donde se dejó esta área mucho tiempo abandonada por el poco avance que se tenia dando pie a un desanimo para la continuación de la investigación. Pero esto, ¿A que se debe?, pues se debe a que la comprensión de las palabras lleva mucho más allá que solo reglas fijas a las que esta sujetas las maquinas. El video ofrece una cita de Groucho Marx, “Una mañana me desperté y maté a un elefante en pijama. Me pregunto cómo pudo ponerse mi pijama.”

El avance de la compresión del lenguaje natural fue muy fuerte cuando IBM presentó Watson el cual era una inteligencia artificial capaz de competir contra los mejores jugadores de Jeopardy el cual es un concurso donde se hacen preguntas de cualquier tema en el cual es fundamental comprender correctamente las preguntas hechas. La manera de trabajar de Watson es sobre la comprensión inicial de la pregunta partiéndola en varias partes posibles, después busca en todo su conjunto de datos que comprende millones y millones de libros, documentos, etc. Luego con muchos algoritmos trabajando al mismo tiempo define algunas posibles respuestas y para finalizar da la respuesta que tenga mejor coincidencia. Pero esto para IBM solo fue el comienzo, IBM procede a realizar una inteligencia artificial para que pueda ayudar a tomar decisiones a través del debate, esto se debe a que las tomas de decisiones por lo general se toman se toman después de un debate para decidir la mejor opción, pero el gran problema sigue presente el cual es generar conceptos el cual para un ser humano es sencillo pero el plantear esto a una maquina representa un problema muy complejo, pero al parecer esto fue desarrollado ya por IBM en donde se presenta a la una inteligencia artificial la cual es capaz de construir argumentos para debatir sobre un tema.

Otro problema que se intenta resolver es la conducción automática, pero esto es muy complicado pues el llevar un automóvil representa un gran riesgo, tanto para las personas fuere de este como para las de dentro, además de que tiene que tomar decisiones en tiempo real y este parece ser el mas complejo en este problema, pues en el día a día las situaciones son muy distintas entre si y la inteligencia artificial debe detectar los objetos de alrededor sin margen a algún error pues no debe detectar algo como un camino o algo por donde debe pasar y estrellarse. El video pone de ejemplo a una Roomba las cuales son maquinas diseñadas para hacer limpieza como barrer y trapear, y es que resulta que estas maquinan suelen chocar unas cuantas veces con la pared y después prenden que ahí no pueden pasar, pero esto no puede pasar en lo que es la conducción automática porque de aquí dependen vidas humanas.

Para el ser humano el aprender es intuitivo y lo que nos ha llevado a lo que hoy en día es nuestro presente, pero para las maquinas es diferente. El aprendizaje de las maquina se ha intentado desde hace mucho y se empezó con un juego de mesa llamado damas chinas en el cual la inteligencia artificial era capaz de revisar en miles de juegos de damas chinas posibles jugadas que pueden conducir a una victoria del juego, pero todo esto era en un tiempo en el que el investigador Samuel como nos lo presentan en el video solo contaba con 256 bytes.

Pero este juego de damas chinas no fue el único con el que se intentó, sino que también se hicieron intentos con el ajedrez donde la inteligencia artificial fue capaz de vencer al campeón mundial de ajedrez.

Otro ejemplo fue el Backgammon o Go, enfocándonos en Go el cual es un juego de mes atan complejo en que hay muchísimas posibles combinaciones, incluso mas que átomos en el universo tal como lo dice el video. Ahora la inteligencia artificial usada en este juego fue diferente a las anteriores pues las anteriores fueron programadas y enseñadas con datos ya existentes, pero en el caso de Go fue un aprendizaje automatizado en la cual la inteligencia artificial fue capaz de aprender Go sin datos a priori del juego o instrucciones dadas por el programados. Aprendió como un humano el cual fue a prueba y error y la inteligencia artificia fue capaz de aprender de sus errores y generando un conjunto de datos.

En el ámbito laboral, es innegable que las IA han transformado la forma en que realizamos ciertas tareas. En campos como la computación, las ciencias naturales y otros sectores, las IA han demostrado ser herramientas valiosas para el procesamiento de datos, el análisis de patrones y la automatización de procesos rutinarios. Sin embargo, es esencial destacar que estas herramientas están destinadas a complementar las habilidades humanas, no a eliminarlas. La interacción colaborativa entre humanos e IA puede conducir a mejoras significativas en la eficiencia y la productividad, pero siempre existe la necesidad de la intuición, la empatía y la toma de decisiones éticas que solo los humanos pueden aportar y un ejemplo de esto es el robot Roger el cual ayuda a empresas en todo el mundo a mejorar su eficiencia, lo interesante en este robot fue que no se le programó para hacer una tarea sino para que se le capacitara para alguna tarea dentro de alguna empresa, como el ejemplo que pone el video, se le capacitó para cortar madera y otro relacionado a la tinta, el cual por u lado es un trabajo muy peligroso y el otro muy tardado y sucio, pero este robot es capaz de hacerlo sin problema una vez se le capacita para hacerlo tal y como lo harías con un humano el cual no tiene nada de experiencia en el área pero se le enseña a un poco a como hacerlo y este lo intenta asimilar y resuelve el como debe hacerlo ya en el momento de trabajar, el robot Roger resulta que era capaz de seguir cortando en la noche cuando los trabajadores se iban lo cual hacia mas eficiente la producción de la empresa, también menciona que los trabajadores cortan un tanto de madera de n maderas y después tienen que volver a hacer el proceso, pero les lleva mucho tiempo, en cambio el robot es capaz de mantener funcionando casi todo el tiempo la sierra para cortar la madera.

En Japón estas tecnologías se ven más robots similares a Roger, pero estos están mas enfocados a parecerse a un humano esto se debe a todo el pensamiento de los japoneses, pero esto según en video no parece ser tan buena idea pues no siempre crear relaciones con la tecnología sería tan buena idea.

Otro punto que tratan en el video es uso de la inteligencia artificial para enseñar a los humano sobre cualquier tema, aunque solo se centran en este punto con los niños y esto se logra con Watson en un videojuego llamado Word Chow el cual les enseña a los niños a aprender sobre palabras, y Watson evalúa las respuestas juntos con su vocabulario y crea ejercicios mas adaptados para el niño y esto parece tener un gran aprendizaje con este juego.

Esto IBM lo ha intentado llevar a cabo para estudiantes y profesores a nivel universitario con una inteligencia artificial llamado Tutor Watson el cual les ayuda a los estudiantes a revisar, repasar y estudiar sobre los temas de las clases

IBM Watson Tutor es una aplicación de inteligencia artificial diseñada específicamente para estudiantes y profesores a nivel universitario. Esta herramienta revolucionaria se basa en la teoría de las inteligencias múltiples de Gardner y utiliza tecnologías avanzadas para personalizar la experiencia de aprendizaje, ofreciendo un enfoque adaptativo y centrado en el estudiante.

Watson Tutor no se limita a un enfoque único de enseñanza. En lugar de ello, se adapta a los estilos de aprendizaje individuales de los estudiantes, reconociendo y aprovechando sus inteligencias múltiples. Esto significa que la herramienta puede personalizar la presentación de la información, las actividades y las evaluaciones para satisfacer las necesidades específicas de cada estudiante.

Watson Tutor ayuda a los estudiantes a revisar y repasar los temas de sus clases de manera personalizada. A través de la inteligencia artificial, identifica las áreas en las que un estudiante puede necesitar refuerzo y proporciona material de estudio específico para fortalecer esas habilidades o conocimientos.

La herramienta no se limita a un simple repaso. Ofrece un apoyo continuo a lo largo del proceso de aprendizaje. Puede responder preguntas en tiempo real, proporcionar explicaciones detalladas y ofrecer recursos adicionales según las necesidades individuales del estudiante.

Watson Tutor realiza un seguimiento del progreso de cada estudiante. Evalúa el rendimiento en las actividades de aprendizaje, identifica áreas de mejora y ajusta su enfoque para maximizar la eficacia del estudio. Este monitoreo continuo permite a los profesores y estudiantes tener una visión clara de los avances y áreas que requieren atención adicional.

La herramienta también facilita la colaboración entre profesores y estudiantes. Los educadores pueden acceder a análisis detallados sobre el rendimiento de cada estudiante, lo que les permite adaptar sus métodos de enseñanza y proporcionar intervenciones personalizadas cuando sea necesario.

Watson Tutor aprovecha tecnologías avanzadas, como el procesamiento del lenguaje natural y la inteligencia artificial, para comprender las preguntas de los estudiantes y proporcionar respuestas coherentes y útiles. Además, utiliza algoritmos de aprendizaje automático para refinar su capacidad de adaptación con el tiempo.

Esta iniciativa de IBM refleja el compromiso continuo de la empresa con la innovación educativa y la aplicación práctica de la inteligencia artificial en entornos de aprendizaje. Al incorporar la teoría de las inteligencias múltiples, Watson Tutor destaca cómo las herramientas tecnológicas pueden potenciar la diversidad de habilidades y estilos de aprendizaje, proporcionando un enfoque educativo más personalizado y efectivo para los estudiantes universitarios.

La combinación de la inteligencia artificial (IA) con la creatividad humana está demostrando ser un recurso invaluable para mejorar la calidad de vida de las personas con discapacidades. En el contexto mencionado, el desarrollo de un brazalete para una persona que experimenta una pérdida gradual de la vista destaca cómo la tecnología puede desempeñar un papel crucial en la superación de desafíos y en la promoción de la autonomía.

El brazalete inteligente se convierte en un asistente visual, proporcionando información en tiempo real y mejorando la movilidad de las personas con discapacidades visuales. Equipado con tecnología de sensores, el dispositivo utiliza la inteligencia artificial para interpretar el entorno y traducir la información visual en datos comprensibles para el usuario.

Crea un corredor virtual y cuando se esta desviando el usuario recibe una vibración. La retroalimentación háptica se integra en el dispositivo, permitiendo que el usuario reciba información táctil cuando se desvía del camino virtual. Por ejemplo, si el usuario se acerca al borde del corredor, el dispositivo proporcionaría vibraciones suaves o pulsaciones para indicar la necesidad de ajustar la dirección. El sistema utiliza sensores ambientales, como cámaras, para mapear el entorno circundante. Esta información se procesa en tiempo real para ajustar dinámicamente la ubicación y la forma del corredor virtual según el entorno actual.

La prueba del corredor virtual con retroalimentación háptica reveló desafíos importantes en condiciones de carrera real. Aunque inicialmente funcionó bien, se encontraron obstáculos a mitad del recorrido. La interferencia de señal de los dispositivos móviles de otros corredores impactó la eficacia del dispositivo, y la lluvia complicó aún más la situación.

La interferencia de señal causada por los celulares de otros corredores planteó un problema notable, afectando la capacidad del dispositivo para proporcionar retroalimentación háptica precisa. Este desafío podría abordarse mediante la exploración de tecnologías de comunicación más avanzadas que minimicen la interferencia, así como la posibilidad de ajustar la frecuencia o el canal de comunicación para cada usuario, reduciendo así las posibilidades de interferencias.

Además, la lluvia y otras condiciones meteorológicas adversas presentaron desafíos adicionales. La necesidad de mejorar la durabilidad del dispositivo bajo condiciones climáticas difíciles se destacó como una prioridad. Se podrían explorar soluciones como la impermeabilización del dispositivo y el uso de materiales resistentes al agua. También se podría considerar la integración de sensores climáticos para adaptar la retroalimentación háptica en tiempo real según las condiciones meteorológicas.

La duración de la batería emergió como un factor crítico, especialmente para eventos deportivos más extensos. Para abordar esto, podría ser beneficioso optimizar la eficiencia energética del dispositivo, considerando baterías de mayor capacidad, técnicas avanzadas de gestión de energía y métodos de carga rápida durante pausas planificadas.

La adaptabilidad del dispositivo a diversos entornos de carrera también se destacó como un aspecto clave. La capacidad de ajustarse a diferentes escenarios, desde carreras urbanas con mucha interferencia de señales hasta carreras rurales con terrenos irregulares, podría mejorarse mediante algoritmos avanzados de procesamiento de señales y mapeo.

Otro gran avance de la inteligencia artificial es el reconocimiento facial. El avance del reconocimiento facial, alimentado por los desarrollos en inteligencia artificial, ha llevado a una revolución en diversas áreas, pero también ha suscitado preocupaciones éticas, especialmente en el contexto de la privacidad. China ha liderado la implementación extensiva de esta tecnología para varios propósitos, generando un debate intenso sobre los límites éticos de su aplicación.

Uno de los usos más destacados del reconocimiento facial en China ha sido su aplicación en la identificación y captura de criminales. Las autoridades han empleado esta tecnología para identificar a personas buscadas, logrando éxitos notables en la detención de sospechosos. Sin embargo, este enfoque plantea preguntas éticas sobre la privacidad y los derechos individuales, especialmente en términos de la posibilidad de identificar a personas sin su consentimiento.

Otro uso polémico es la exposición pública de conductas consideradas inapropiadas, como cruzar calles fuera del tiempo designado. Este tipo de aplicación plantea preocupaciones sobre la vigilancia intrusiva y la posibilidad de que la tecnología se utilice para controlar y castigar comportamientos que pueden no representar amenazas significativas.

La implementación generalizada del reconocimiento facial requiere la recopilación masiva de datos personales. Esto plantea preguntas éticas sobre la transparencia en la recopilación y el almacenamiento de datos, así como la posibilidad de un uso indebido de información sensible. La falta de consentimiento informado es un problema ético central. Muchas personas pueden no estar al tanto de la cantidad de datos que se recopilan a través del reconocimiento facial ni de cómo se utilizan. Este vacío en el conocimiento compromete la capacidad de los individuos para controlar su propia información.

Otra implementación del que habla el video es sobre la detección de personas homosexuales y heterosexuales, lo cual a mi parecer es algo raro e innecesario pero no deja de ser un avance, pues reconocer algo así parece ser un como complejo debido a que no es algo visible, pero el video plantea que se puede reconocer esto con rasgos faciales, y al final los resultados fueron que reconocieron a las personas con su orientación sexual con un 81% de precisión en los hombre y 74% de precisión en las mujeres.

Esto anterior se intenta usar para la identificación de posibles ladrones o criminales basados en la imagen facial, expresión facial entre otros. Face Seption tal parece se llama, a diferencia de reconocimiento fácil no busca vincular una persona con antecedentes penales sino lo que busca es reconocer personas que puedan ser posibles criminales por lo que no tiene una base de datos faciales.

La aplicación de la inteligencia artificial, como se ejemplifica con el caso del Parkinson en el video, promete transformar el ámbito médico al proporcionar herramientas avanzadas para analizar y correlacionar grandes cantidades de datos médicos. En el caso específico de enfermedades como el Parkinson, donde los movimientos involuntarios y la falta de una cura definitiva presentan desafíos significativos, el uso de tecnologías como Watson para el análisis de datos médicos se presenta como una solución potencialmente revolucionaria.

La riqueza de información médica disponible, desde estudios clínicos hasta historias de pacientes, se convierte en una fuente valiosa para la inteligencia artificial. Watson, en este contexto, tiene la capacidad de procesar enormes cantidades de datos y extraer patrones, correlaciones y posibles tratamientos que podrían pasar desapercibidos para el ojo humano. Este enfoque computacional permite abordar la complejidad de enfermedades como el Parkinson, donde la variabilidad en la presentación de síntomas y la falta de una solución única hacen que el proceso de tratamiento sea desafiante.

Sin embargo, la verdadera complejidad radica en la implementación práctica de las recomendaciones generadas por la inteligencia artificial. La sugerencia de una lista extensa de medicamentos potenciales es solo el primer paso. La selección y prueba de estos medicamentos en pacientes reales es un proceso delicado que implica consideraciones éticas, la seguridad del paciente y la eficacia real de los tratamientos propuestos.

La fase de prueba y validación se convierte en un elemento crucial del proceso. La esperanza de encontrar tratamientos efectivos se basa en identificar medicamentos con una mayor probabilidad de éxito, y aquí es donde la colaboración entre la inteligencia artificial y el juicio clínico humano se vuelve esencial. Los profesionales de la salud deben evaluar la viabilidad y seguridad de implementar las recomendaciones generadas, considerando factores como la respuesta individual de los pacientes, posibles efectos secundarios y otros riesgos asociados.

Además, la implementación exitosa de estas soluciones también está sujeta a la aceptación y colaboración de la comunidad médica. La introducción de la inteligencia artificial en la toma de decisiones clínicas plantea cuestionamientos sobre la confiabilidad de los algoritmos y la necesidad de una comprensión profunda de cómo se llega a ciertas conclusiones. La transparencia en el proceso y la capacidad de los profesionales de la salud para comprender y cuestionar las recomendaciones de la inteligencia artificial son esenciales para su integración efectiva en el campo médico.

La exploración de la inteligencia artificial, desde su aplicación en medicina con herramientas como Watson hasta la mejora de la visión artificial y su papel en la innovación en videojuegos, destaca su potencial transformador para el avance humano. Estas aplicaciones demuestran la capacidad de la inteligencia artificial para procesar datos de manera eficiente, ofrecer soluciones innovadoras y abordar desafíos en diversas áreas. Sin embargo, su éxito depende de una implementación ética, colaboración con expertos humanos y una comprensión profunda de las implicaciones tanto positivas como éticas de su integración en la sociedad. En conjunto, la inteligencia artificial emerge como una herramienta poderosa con el potencial de mejorar la calidad de vida y promover el progreso en diversos campos.

# Introducción a la Inteligencia Artificial: Tipos de Inteligencia.

## Escribir un ensayo mínimo de 4 cuartillas de la teoría de las inteligencias múltiples según Gardner

### Introducción

En el desarrollo de la teoría de las inteligencias múltiples, Howard Gardner desafía la perspectiva tradicional de la inteligencia como una entidad única y cuantificable. En lugar de adherirse a la visión limitada de las pruebas de coeficiente intelectual, Gardner propone un modelo más holístico que reconoce diversas capacidades cognitivas. La esencia de esta teoría descansa en la premisa de que la inteligencia no se puede encapsular en una única dimensión, sino que se manifiesta en múltiples formas.

El marco teórico de Gardner identifica nueve inteligencias distintas, cada una representando una categoría única de habilidades y aptitudes. Estas incluyen, entre otras, la inteligencia lingüística-verbal, lógico-matemática, espacial, musical, corporal-cinestésica, interpersonal, intrapersonal, naturalista y existencial. Cada una de estas inteligencias refleja una capacidad específica para entender y abordar el mundo que nos rodea.

Esta conceptualización de la inteligencia no solo diversifica el panorama cognitivo, sino que también tiene profundas implicaciones en la educación. Gardner propone que los métodos pedagógicos deben adaptarse para abordar las distintas formas de aprendizaje y expresión de los estudiantes, reconociendo que cada individuo puede sobresalir en áreas específicas.

Explorar esta teoría implica desplazarse más allá de las métricas tradicionales de rendimiento académico y sumergirse en la riqueza de habilidades y talentos que conforman la inteligencia humana. Este marco teórico sienta las bases para comprender cómo las diversas inteligencias interactúan y se entrelazan en la experiencia humana, y cómo su reconocimiento puede informar estrategias más efectivas y personalizadas en el ámbito educativo.

### Desarrollo

La visión revolucionaria de Howard Gardner sobre las inteligencias múltiples va más allá de una simple enumeración de capacidades cognitivas. Proporciona un marco conceptual que transforma fundamentalmente la manera en que entendemos la inteligencia y, por ende, cómo abordamos la enseñanza y la evaluación en el ámbito educativo.

- Enriquecimiento de la Comprensión de la Diversidad Humana:
  Al reconocer y describir nueve inteligencias distintas, Gardner amplía significativamente nuestra comprensión de la diversidad humana. Este enfoque reconoce que cada individuo posee combinaciones únicas de habilidades y talentos, desafiando la noción de que la inteligencia puede medirse de manera uniforme. Al aceptar la multiplicidad de formas en que las personas son inteligentes, se fomenta un ambiente que valora la diversidad y la singularidad de cada individuo.
- Impacto en la Enseñanza:
  La teoría de las inteligencias múltiples ha transformado la forma en que se aborda la enseñanza. En lugar de un enfoque estándar que se centra exclusivamente en habilidades verbales y matemáticas, los educadores pueden adoptar estrategias más diversas que aborden las diversas inteligencias. Por ejemplo, la incorporación de métodos visuales, prácticas de aprendizaje experiencial y actividades musicales permite llegar a estudiantes con diferentes fortalezas cognitivas.
- Personalización del Aprendizaje:
  Gardner propone que la enseñanza debe ser personalizada para adaptarse a las fortalezas y preferencias individuales de los estudiantes. Este enfoque implica identificar y cultivar las inteligencias dominantes de cada estudiante, permitiéndoles desarrollar su potencial máximo. La personalización del aprendizaje crea un entorno educativo más inclusivo, donde los estudiantes se sienten valorados por sus habilidades individuales.
- Evaluación Integral:
  La teoría de las inteligencias múltiples también tiene implicaciones significativas para la evaluación. Los métodos de evaluación pueden diversificarse para reflejar las múltiples formas en que los estudiantes pueden demostrar comprensión y habilidad. No se limita a pruebas escritas tradicionales; incluye proyectos creativos, presentaciones orales, demostraciones prácticas y otros enfoques que permiten a los estudiantes destacar en sus áreas de inteligencia dominantes.
- Desarrollo del Potencial Individual:
  Este enfoque educativo no solo se trata de mejorar el rendimiento académico, sino de nutrir el desarrollo integral de cada individuo. La teoría de las inteligencias múltiples aboga por un enfoque holístico que considere tanto las habilidades académicas como las habilidades prácticas y creativas. Esto puede traducirse en una mayor motivación y satisfacción en el proceso de aprendizaje, ya que los estudiantes se ven reconocidos y apoyados en sus talentos individuales.

Gardner identificó inicialmente siete inteligencias en su teoría, y más tarde agregó una octava. Estas inteligencias son:

1. Inteligencia Lingüística-Verbal: La inteligencia lingüística-verbal, según la teoría de las inteligencias múltiples de Howard Gardner, abarca una rica variedad de habilidades relacionadas con el uso y comprensión del lenguaje. Esta inteligencia va más allá de la mera capacidad de hablar y escribir, incluyendo la habilidad para utilizar el lenguaje de manera efectiva en diferentes contextos y para diferentes propósitos.

   Las personas con una fuerte inteligencia lingüística-verbal son hábiles en la expresión oral. Tienen la capacidad de comunicar ideas de manera clara y persuasiva, utilizando un vocabulario rico y estructuras gramaticales precisas. Su facilidad para expresarse verbalmente los destaca en situaciones de debate, presentaciones y conversaciones.

   Esta inteligencia también abarca las habilidades escritas. Aquellos con aptitudes lingüísticas fuertes son capaces de plasmar sus pensamientos de manera efectiva en papel. Pueden crear textos coherentes, persuasivos y estilísticamente ricos, ya sea en forma de ensayos, poesía o prosa.

   La inteligencia lingüística-verbal se relaciona estrechamente con la capacidad de comprender textos escritos. Las personas con esta inteligencia son hábiles en la interpretación de información y la extracción de significado de textos complejos. Su aguda comprensión les permite absorber conocimientos de manera efectiva a través de la lectura.

   La habilidad para escuchar y comprender también es una parte integral de esta inteligencia. Las personas con fuerte inteligencia lingüística-verbal pueden captar matices en la comunicación oral, interpretando no solo las palabras sino también las intenciones y emociones subyacentes en el discurso.

2. Inteligencia Lógico-Matemática: La inteligencia lógico-matemática, según la teoría de las inteligencias múltiples de Howard Gardner, se centra en la capacidad de razonar de manera lógica, resolver problemas matemáticos y comprender conceptos abstractos. Aquí se exploran los componentes clave de esta inteligencia y cómo influyen en la forma en que las personas abordan el mundo que las rodea:

   1. Razonamiento Lógico
   2. Resolución de Problemas
   3. Comprensión de Conceptos Abstractos
   4. Habilidad Numérica
   5. Pensamiento Analítico
   6. Aptitud para la Ciencia
   7. Pensamiento Estratégico

   Esta inteligencia no solo es crucial en campos científicos y matemáticos, sino que también juega un papel esencial en la vida cotidiana al potenciar el pensamiento crítico y la toma de decisiones fundamentadas en la lógica y el razonamiento. En el ámbito educativo, reconocer y cultivar esta inteligencia puede enriquecer la experiencia de aprendizaje y preparar a los individuos para enfrentar desafíos complejos de manera efectiva.

3. Inteligencia Espacial: La inteligencia espacial, en el marco de las inteligencias múltiples de Howard Gardner, abarca la habilidad para percibir, entender y manipular información visual y espacial. Aquí se explora en profundidad esta forma única de inteligencia y cómo se manifiesta en diversas áreas:

   1. Visualización e Imaginación: La capacidad para visualizar objetos, escenas y conceptos en la mente es una característica central de la inteligencia espacial.
   2. Orientación Espacial: La inteligencia espacial también se relaciona con la habilidad para entender y utilizar la información espacial en el entorno físico. Esto incluye la capacidad para navegar eficientemente en el espacio, comprender mapas y representaciones gráficas, y tener una conciencia espacial precisa.
   3. Percepción de Formas y Patrones: Aquellos con inteligencia espacial son hábiles en la percepción de formas y patrones en el mundo que los rodea. Pueden identificar relaciones visuales y reconocer simetrías, lo que es valioso en campos como la geometría, la fotografía y la escultura.
   4. Reconocimiento de Rostros: La inteligencia espacial también puede influir en la capacidad para reconocer caras y expresiones faciales. La habilidad para percibir y recordar detalles visuales específicos contribuye a la competencia en esta área.

4. Inteligencia Musical: La inteligencia musical, identificada por Howard Gardner en su teoría de las inteligencias múltiples, destaca la habilidad para percibir, entender, crear y apreciar la música en sus diversas formas. La inteligencia musical va más allá de la capacidad de ejecutar notas musicales; implica una comprensión profunda de la esencia y la estructura de la música. En el ámbito educativo, reconocer y fomentar esta inteligencia puede enriquecer la experiencia de aprendizaje, permitiendo a los estudiantes explorar y expresarse a través del lenguaje universal de la música.

5. Inteligencia Corporal-Cinestésica: La inteligencia corporal-cinestésica, en el marco de las inteligencias múltiples de Howard Gardner, destaca la habilidad para utilizar el cuerpo de manera coordinada y expresiva. Esta inteligencia se manifiesta en diversas actividades que involucran el movimiento y la destreza física.

6. Inteligencia Interpersonal: La inteligencia interpersonal, dentro de la teoría de las inteligencias múltiples de Howard Gardner, se centra en la capacidad de entender y relacionarse efectivamente con otras personas. Esta forma de inteligencia resalta la importancia de las relaciones interpersonales y la capacidad de percibir y responder a las emociones, motivaciones y estados mentales de los demás. A continuación, se exploran los aspectos clave de la inteligencia interpersonal:

   1. Empatía: Comprender y compartir emociones.
   2. Comunicación Efectiva: Habilidad para expresarse y escuchar.
   3. Habilidades Sociales: Establecer y mantener relaciones.
   4. Resolución de Conflictos: Negociar y mediar de manera efectiva.
   5. Liderazgo y Colaboración: Dirigir grupos y trabajar en equipo.
   6. Construcción de Redes Sociales: Crear conexiones significativas.
   7. Sensibilidad Cultural: Entender y respetar diversidades.
   8. Motivación e Inspiración: Estimular y guiar a otros.
   9. Comprensión de Emociones: Reconocer y responder a estados emocionales.

7. Inteligencia Intrapersonal: La inteligencia intrapersonal, en el contexto de las inteligencias múltiples de Howard Gardner, se refiere a la capacidad de conocerse a uno mismo, comprender las propias emociones, motivaciones y valores. A continuación, se exploran en detalle los aspectos fundamentales de esta inteligencia:

   1. Autoconocimiento: Conciencia profunda de uno mismo.
   2. Autocontrol Emocional: Habilidad para gestionar emociones.
   3. Motivación Interna: Impulso y autodisciplina personales.
   4. Autoevaluación y Reflexión: Aprender de experiencias personales.
   5. Autoeficacia: Creencia en la propia capacidad.
   6. Claridad en Valores: Comprender valores personales.
   7. Autodirección en el Aprendizaje: Controlar el proceso educativo.
   8. Resiliencia Emocional: Recuperarse de adversidades.
   9. Desarrollo de la Autoestima: Construcción de una autoimagen positiva.

8. Inteligencia Naturalista: La inteligencia naturalista, según la teoría de las inteligencias múltiples de Howard Gardner, se centra en la conexión y comprensión de los elementos naturales del entorno. Esta inteligencia destaca la conexión profunda con la naturaleza y la apreciación de la biodiversidad. Aquí, profundizamos en los aspectos clave de esta inteligencia:
   1. Observación y Patrones Naturales: Reconocimiento de patrones en la naturaleza.
   2. Conexión Emocional con la Naturaleza: Atracción y aprecio por entornos naturales.
   3. Clasificación y Categorización: Identificación y clasificación de elementos naturales.
   4. Comprensión de Ciclos Naturales: Conocimiento de ciclos de vida y estacionales.
   5. Conciencia Ambiental: Comprensión de interacciones humano-ambientales.
   6. Habilidades de Jardinería: Cultivo y cuidado de plantas.
   7. Navegación en la Naturaleza: Orientación en entornos naturales.
   8. Estudio de Ciencias Naturales: Interés y estudio en biología y ciencias naturales.
   9. Respeto y Ética Ambiental: Valoración y protección del medio ambiente.

#### Aplicaciones Prácticas de las Inteligencias Múltiples:

La teoría de las inteligencias múltiples propuesta por Howard Gardner ofrece un marco robusto para comprender la diversidad de habilidades cognitivas y emocionales presentes en los individuos. A medida que exploramos más allá de las distintas inteligencias, surge la pregunta crucial: ¿cómo se aplican estas teorías en la vida cotidiana, especialmente en entornos educativos, profesionales y de desarrollo personal?

En el ámbito educativo, las inteligencias múltiples encuentran su aplicación práctica en estrategias pedagógicas que reconocen y se adaptan a las fortalezas individuales. Los educadores pueden diseñar actividades que aborden diversas inteligencias, permitiendo que los estudiantes exploren y desarrollen sus habilidades de manera más completa. Esta aproximación personalizada no solo enriquece el aprendizaje, sino que también fomenta un ambiente inclusivo que valora las diferencias cognitivas.

La evaluación de las inteligencias múltiples proporciona una visión más holística del rendimiento individual. Se exploran metodologías que van más allá de las evaluaciones tradicionales para incluir la diversidad de habilidades cognitivas y emocionales. Este enfoque ampliado no solo informa sobre el progreso académico, sino que también ayuda a los educadores y profesionales a entender mejor las áreas de fortaleza y aquellas que pueden necesitar mayor desarrollo.

Las inteligencias múltiples son un recurso invaluable en el desarrollo personal y profesional. Aquellos que comprenden sus propias inteligencias pueden aprovechar esta información para mejorar la autoeficacia, establecer metas alineadas con sus habilidades clave y cultivar una mayor autoconciencia emocional. Además, las empresas pueden utilizar esta perspectiva para formar equipos más equilibrados, aprovechando una gama completa de habilidades para abordar desafíos complejos.

Los programas de desarrollo personal basados en las inteligencias múltiples ofrecen un enfoque integral. Al reconocer y fortalecer habilidades específicas, estos programas permiten que los individuos se desarrollen de manera equilibrada, potenciando tanto las habilidades académicas como las habilidades sociales y emocionales.

### Conclusión

En el recorrido por las inteligencias múltiples de Gardner, emergen perspectivas reveladoras sobre la complejidad humana. Esta teoría va más allá de la visión convencional de la inteligencia, destacando una diversidad de habilidades cognitivas y emocionales únicas en cada individuo.

La aplicación práctica de las inteligencias múltiples se despliega en ámbitos educativos, personales y profesionales. Desde estrategias de enseñanza adaptativas hasta evaluaciones integrales, estas inteligencias ofrecen un enfoque que honra las fortalezas individuales.

En el mundo laboral, las inteligencias múltiples modelan equipos colaborativos y eficientes, convirtiendo la diversidad de habilidades en un valioso activo. A pesar de los desafíos y críticas, esta teoría nos recuerda la riqueza que surge al abrazar la diversidad cognitiva y emocional.

En última instancia, las inteligencias múltiples nos inspiran a celebrar la singularidad de cada individuo, enriqueciendo nuestras vidas y contribuyendo a comunidades más comprensivas. Este enfoque ilumina el camino hacia un mundo donde cada uno puede desplegar su potencial de manera única y valiosa.

# Introducción a la Inteligencia Artificial: Introspección

Coloca ocho alfiles (cuatro negros y cuatro blancos) en un tablero de ajedrez reducido, tal como se ve en la figura. El problema consiste en hacer que los alfiles negros intercambien sus posiciones con los blancos, ningún alfil debe atacar en ningún momento otro del color opuesto. Se deben alternarlos movimientos, primero uno blanco, luego uno negro, luego uno blanco y así sucesivamente. ¿Cuál es el mínimo número de movimientos en que se puede conseguir?

La estrategia para lograr el intercambio de posiciones de los alfiles negros y blancos implica realizar movimientos en sentido horario. Inicialmente, se elige un alfil y se lo mueve a una casilla vacía, luego se repite el proceso con el alfil del color opuesto, siguiendo un patrón de movimientos en sentido horario alrededor del tablero. Este enfoque garantiza que los alfiles se redistribuyan sin ponerse en posición de ataque mutuo. La secuencia de movimientos sigue un patrón cíclico, alternando entre alfiles negros y blancos, hasta lograr la configuración deseada sin conflictos.
En mi método empecé por el alfil 3 de los que están arriba, lo moví hasta el otro extremo, después hice su espejo en los del otro lado. Después la esquina que puede llegar en 2 movimientos a los lugares vacíos. La cantidad mínima de movimientos en lo que lo logré hacer fuer de 36 movimientos

# Introducción a la Inteligencia Artificial: Introspección

## Hacer un programa que pueda contar el numero de elementos que son del mismo color

```python
   def visitar_isla(matriz, visitado, i, j, filas, columnas):
   if i < 0 or i >= filas or j < 0 or j >= columnas or matriz[i][j] == 0 or visitado[i][j]:
   return

      visitado[i][j] = True

      visitar_isla(matriz, visitado, i + 1, j, filas, columnas)
      visitar_isla(matriz, visitado, i - 1, j, filas, columnas)
      visitar_isla(matriz, visitado, i, j + 1, filas, columnas)
      visitar_isla(matriz, visitado, i, j - 1, filas, columnas)

   matriz_ejemplo = [
   [0, 0, 0, 0, 0, 0, 1, 1],
   [0, 1, 1, 0, 0, 1, 0, 0],
   [0, 1, 1, 0, 0, 0, 0, 0],
   [0, 0, 0, 0, 0, 1, 1, 1],
   [0, 0, 1, 1, 0, 0, 0, 0]
   ]

   filas, columnas = len(matriz*ejemplo), len(matriz_ejemplo[0])
   visitado = [[False] * columnas for _ in range(filas)]
   count_islas = 0

   for i in range(filas):
   for j in range(columnas):
   if matriz_ejemplo[i][j] == 1 and not visitado[i][j]:
   count_islas += 1
   visitar_isla(matriz_ejemplo, visitado, i, j, filas, columnas)

   print("Número de islas:", count_islas)
```

# Introducción a la Inteligencia Artificial: Introspección

## Una vez que se resolvió el algoritmo de las islas en la siguiente imagencontar los elementos que tienen el color rojo

```python
import cv2 as cv
import numpy as np


def visitar_isla_roja(matriz, visitado, inicio_fila, inicio_columna, filas, columnas):
    stack = [(inicio_fila, inicio_columna)]
    isla_size = 0

    while stack:
        i, j = stack.pop()
        if 0 <= i < filas and 0 <= j < columnas and matriz[i][j] == 255 and not visitado[i][j]:
            visitado[i][j] = True
            isla_size += 1

            stack.append((i + 1, j))
            stack.append((i - 1, j))
            stack.append((i, j + 1))
            stack.append((i, j - 1))

    return isla_size

def contar_islas_rojas(matriz, elementos_minimos=100):
    filas, columnas = matriz.shape
    visitado = np.zeros_like(matriz, dtype=bool)
    count_islas = 0

    for i in range(filas):
        for j in range(columnas):
            if matriz[i][j] == 255 and not visitado[i][j]:
                isla_size = visitar_isla_roja(matriz, visitado, i, j, filas, columnas)
                if isla_size >= elementos_minimos:
                    count_islas += 1

    return count_islas


imagen = "f1.jpg"

imgColorOriginal = cv.imread(imagen, 1)
imgColorOriginal1 = cv.cvtColor(imgColorOriginal, cv.COLOR_BGR2RGB)
imgColorOriginal2 = cv.cvtColor(imgColorOriginal1, cv.COLOR_RGB2HSV)

umbralBajo = (0, 80, 80)
umbralAlto = (10, 255, 255)
umbralBajoB = (170, 80, 80)
umbralAltoB = (180, 255, 255)

mascara = cv.inRange(imgColorOriginal2, umbralBajo, umbralAlto)
mascara2 = cv.inRange(imgColorOriginal2, umbralBajoB, umbralAltoB)

mascara = mascara + mascara2
resultado = cv.bitwise_and(imgColorOriginal, imgColorOriginal, mask=mascara)

cv.imshow('resultado', resultado)
cv.imshow('mascara', mascara)
cv.imshow('imgColorOriginal', imgColorOriginal)

matriz_imagen = np.array(mascara)

count_islas = contar_islas_rojas(matriz_imagen, 200)

print("Número de islas:", count_islas)

cv.waitKey(0)
cv.destroyAllWindows()
```

# Introducción a la Inteligencia Artificial: El proceso de razonamiento según la lógica

## Problema de Josephus y los soldados

Supongamos que hay _n_ soldados numerados del 1 al _n_ en un círculo. El problema consiste en determinar en qué posición debe sentarse Josephus para ser el último sobreviviente.

Denotemos la posición ganadora como _f(n)_, es decir, la posición en la que Josephus debería sentarse cuando hay _n_ soldados.

La regla para eliminar a cada soldado es la siguiente: el soldado en la posición _i_ eliminará al soldado en la posición _i+1_, y cuando lleguemos al final del círculo, volveremos al soldado en la posición 1.

## Plantear la solución para varios casos:

### Casos para _n=1_:

Cuando hay un solo soldado, Josephus es el único y su posición ganadora es 1.
_f(1)=1_

### Casos para _n=2_:

El soldado en la posición 1 eliminará al soldado en la posición 2, por lo que Josephus debe sentarse en la posición 1.
_f(2)=1_

### Casos para _n=3_:

1. El soldado en la posición 1 elimina al soldado en la posición 2.
2. El soldado en la posición 3 elimina al soldado en la posición 1.
   Entonces, Josephus debe sentarse en la posición 3.
   _f(3)=3_

### Casos para _n=4_:

1. El soldado en la posición 1 elimina al soldado en la posición 2.
2. El soldado en la posición 3 elimina al soldado en la posición 4.
3. El soldado en la posición 1 elimina al soldado en la posición 3.
   Entonces, Josephus debe sentarse en la posición 1.
   _f(4)=1_

### Casos para _n=5_:

1. El soldado en la posición 1 elimina al soldado en la posición 2.
2. El soldado en la posición 3 elimina al soldado en la posición 4.
3. El soldado en la posición 5 elimina al soldado en la posición 1.
4. El soldado en la posición 3 elimina al soldado en la posición 5.
   Entonces, Josephus debe sentarse en la posición 3.
   _f(5)=3_

### Casos para _n=6_:

1. El soldado en la posición 1 elimina al soldado en la posición 2.
2. El soldado en la posición 3 elimina al soldado en la posición 4.
3. El soldado en la posición 5 elimina al soldado en la posición 6.
4. El soldado en la posición 1 elimina al soldado en la posición 3.
5. El soldado en la posición 5 elimina al soldado en la posición 1.
   Entonces, Josephus debe sentarse en la posición 5.
   _f(6)=5_

### Casos para _n=7_:

1. El soldado en la posición 1 elimina al soldado en la posición 2.
2. El soldado en la posición 3 elimina al soldado en la posición 4.
3. El soldado en la posición 5 elimina al soldado en la posición 6.
4. El soldado en la posición 7 elimina al soldado en la posición 1.
5. El soldado en la posición 3 elimina al soldado en la posición 5.
6. El soldado en la posición 7 elimina al soldado en la posición 3.
   Entonces, Josephus debe sentarse en la posición 7.
   _f(7)=7_

### Casos para _n=8_:

1. El soldado en la posición 1 elimina al soldado en la posición 2.
2. El soldado en la posición 3 elimina al soldado en la posición 4.
3. El soldado en la posición 5 elimina al soldado en la posición 6.
4. El soldado en la posición 7 elimina al soldado en la posición 8.
5. El soldado en la posición 1 elimina al soldado en la posición 3.
6. El soldado en la posición 5 elimina al soldado en la posición 7.
7. El soldado en la posición 1 elimina al soldado en la posición 5.
   Entonces, Josephus debe sentarse en la posición 1.
   _f(8)=1_

### Casos para _n=9_:

1. El soldado en la posición 1 elimina al soldado en la posición 2.
2. El soldado en la posición 3 elimina al soldado en la posición 4.
3. El soldado en la posición 5 elimina al soldado en la posición 6.
4. El soldado en la posición 7 elimina al soldado en la posición 8.
5. El soldado en la posición 9 elimina al soldado en la posición 1.
6. El soldado en la posición 3 elimina al soldado en la posición 5.
7. El soldado en la posición 7 elimina al soldado en la posición 9.
8. El soldado en la posición 3 elimina al soldado en la posición 7.
   Entonces, Josephus debe sentarse en la posición 3.
   _f(9)=3_

### Casos para _n=10_:

1. El soldado en la posición 1 elimina al soldado en la posición 2.
2. El soldado en la posición 3 elimina al soldado en la posición 4.
3. El soldado en la posición 5 elimina al soldado en la posición 6.
4. El soldado en la posición 7 elimina al soldado en la posición 8.
5. El soldado en la posición 9 elimina al soldado en la posición 10.
6. El soldado en la posición 1 elimina al soldado en la posición 3.
7. El soldado en la posición 5 elimina al soldado en la posición 7.
8. El soldado en la posición 9 elimina al soldado en la posición 1.
9. El soldado en la posición 5 elimina al soldado en la posición 9.
   Entonces, Josephus debe sentarse en la posición 5.
   _f(10)=5_

## Resultados

|  n  | Resultado |
| :-: | :-------: |
|  1  |     1     |
|  2  |     1     |
|  3  |     3     |
|  4  |     1     |
|  5  |     3     |
|  6  |     5     |
|  7  |     7     |
|  8  |     1     |
|  9  |     3     |
| 10  |     5     |

Hasta este punto, se pueden observar 2 patrones:

1. Cuando _n_ es una potencia de 2 (como 1, 2, 4, 8, ...), la posición ganadora es siempre 1. Esto concuerda con la observación de que Josephus debería sentarse en la posición 1 cuando el número de soldados es una potencia de 2.
2. Cuando _n_ no es una potencia de 2, la posición ganadora parece seguir un patrón que no es simplemente _n_. En cambio, parece relacionarse con la distancia a la potencia de 2 más cercana que es menor o igual a _n_.

### Generalizando seguimos con las observaciones de los patrones en formulas:

1. **Potencia de 2:**
   - Cuando _n_ es una potencia de 2, la posición ganadora es siempre 1.
   - Ejemplos: _f(1)=1_, _f(2)=1_, _f(4)=1_, etc.
2. **Distancia a la Potencia de 2:**
   - Cuando _n_ no es una potencia de 2, la posición ganadora parece estar relacionada con la distancia a la potencia de 2 más cercana que es menor o igual a _n_.
   - Esta distancia es _n - 2⌊log₂(n)⌋_.

**Fórmula General:**
_f(n)=2⋅(n−2^⌊log₂(n)⌋)+1_

Esta fórmula sugiere que la posición ganadora se calcula tomando la distancia de _n_ a la potencia de 2 más cercana, multiplicándola por 2, y luego sumándole 1.

```python
import math

def josephus_position(n):
    power_of_two = 2 ** int(math.log2(n))
    return 2 * (n - power_of_two) + 1

n_soldiers = 41
winner_position = josephus_position(n_soldiers)
print(f"Josephus debe sentarse en la posición {winner_position} para sobrevivir.")
```

# Introducción a la Inteligencia Artificial: El papel de la heurística

## Definir que es la heurística y cual es su papel en la resolución de problemas

La heurística hace referencia al uso de normas amplias o métodos prácticos para abordar problemas y tomar decisiones, especialmente cuando se enfrenta a situaciones complejas o inciertas. Este enfoque se basa en la experiencia adquirida, el sentido común y la intuición, en lugar de seguir un conjunto estricto de reglas o algoritmos formales.

El papel de las estrategias prácticas en la resolución de problemas ayuda a tomar decisiones de manera eficiente y rápida en situaciones donde la información es limitada o el tiempo es poco. A continuación, se destacan algunas características y funciones clave de las estrategias prácticas para resolver problemas:

1. Simplificar el problema: Las estrategias prácticas a menudo implican simplificar un problema complejo al enfocarse en aspectos específicos y relevantes. Esto ayuda a reducir la carga mental y facilita la toma de decisiones de forma rápida.
2. Rapidez: Los atajos permiten tomar decisiones rápidas al evitar un análisis exhaustivo de todas las posibilidades disponibles. En lugar de considerar todas las alternativas posibles, se toma un camino más corto para llegar a una solución aceptable.
3. Ahorro de esfuerzos: Al utilizar atajos, se evita la necesidad de recursos significativos, como tiempo y esfuerzo mental, que serían requeridos para analizar exhaustivamente todas las opciones.
4. Adaptabilidad: Los atajos son adaptables a diferentes situaciones y contextos. Pueden ser herramientas eficaces para la toma de decisiones en entornos cambiantes.
5. Errores comunes: Aunque los atajos son útiles, también pueden dar lugar a errores comunes o sesgos cognitivos. Estos errores pueden surgir cuando las reglas de los atajos no son aplicables o cuando conducen a conclusiones subóptimas.

Ejemplos comunes de heurísticas incluyen "regla del pulgar", "usar la primera solución que parece adecuada" o "seguir la mayoría". Aunque los atajos pueden ser eficaces, es importante reconocer sus limitaciones y comprender cuándo es apropiado aplicarlas en la resolución de problemas.

## Resolver con recursividad, programar.

```python
def is_valid_move(labyrinth, x, y):
    rows, cols = len(labyrinth), len(labyrinth[0])
    return 0 <= x < rows and 0 <= y < cols and labyrinth[x][y] == 0


def recursive_solve(labyrinth, current, goal, path):
    x, y = current
    if current == goal:
        return True
    if not is_valid_move(labyrinth, x, y) or current in path:
        return False

    path.append(current)

    neighbors = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]

    for neighbor in neighbors:
        if recursive_solve(labyrinth, neighbor, goal, path):
            return True

    path.pop()
    return False


labyrinth = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 1, 1, 0, 1, 1, 1, 0, 1],
    [1, 0, 0, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 0, 1],
    [0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1],
]

start = (1, 0)
goal = (7, 0)

recursive_path = []
recursive_solution = recursive_solve(labyrinth, start, goal, recursive_path)
print("Recursive Algorithm:")
if recursive_solution:
    print("Solution found:")
    for step in recursive_path:
        print(step)
else:
    print("No solution found.")
```

## Proponer Algoritmo de Solución, programar.

```python
import heapq

class Node:
    def __init__(self, x, y, parent=None):
        self.x = x
        self.y = y
        self.parent = parent
        self.g = 0
        self.h = 0

    def __lt__(self, other):
        # Se usa < para comparar nodos y determinar cuál es menor
        return (self.g + self.h) < (other.g + other.h)

def is_valid_move(labyrinth, x, y):
    rows, cols = len(labyrinth), len(labyrinth[0])
    return 0 <= x < rows and 0 <= y < cols and labyrinth[x][y] == 0

def heuristic(node, goal):
    # Distancia Manhattan entre el nodo y la meta
    return abs(node.x - goal[0]) + abs(node.y - goal[1])

def reconstruct_path(current_node):
    path = []
    while current_node:
        path.append((current_node.x, current_node.y))
        current_node = current_node.parent
    # El path se construye del final al inicio, por lo que hay que invertirlo
    return path[::-1]

def a_star(labyrinth, start, goal):
    open_set = []
    closed_set = set()

    start_node = Node(start[0], start[1])
    goal_node = Node(goal[0], goal[1])

    heapq.heappush(open_set, start_node)

    while open_set:
        current_node = heapq.heappop(open_set)

        if (current_node.x, current_node.y) == (goal_node.x, goal_node.y):
            return reconstruct_path(current_node)

        closed_set.add((current_node.x, current_node.y))

        neighbors = [(current_node.x + 1, current_node.y),
                     (current_node.x - 1, current_node.y),
                     (current_node.x, current_node.y + 1),
                     (current_node.x, current_node.y - 1)]

        for neighbor in neighbors:
            if neighbor not in closed_set and is_valid_move(labyrinth, *neighbor):
                neighbor_node = Node(neighbor[0], neighbor[1], current_node)
                neighbor_node.g = current_node.g + 1
                neighbor_node.h = heuristic(neighbor_node, goal)

                if neighbor_node not in open_set:
                    heapq.heappush(open_set, neighbor_node)

labyrinth = [
    [1, 1, 1, 1, 1, 1, 1, 1, 1],
    [0, 0, 0, 0, 0, 0, 1, 0, 1],
    [1, 1, 1, 0, 1, 1, 1, 0, 1],
    [1, 0, 0, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 1, 1, 0, 1, 0, 1],
    [0, 0, 1, 0, 0, 0, 1, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1]
]

start = (1, 0)
goal = (7, 0)

a_star_solution = a_star(labyrinth, start, goal)
print("A* Algorithm:")
if a_star_solution:
    print("Solution found:")
    for step in a_star_solution:
        print(step)
else:
    print("No solution found.")
```

## Describir el punto anterior

El algoritmo A* es un algoritmo de búsqueda de rutas que se utiliza para encontrar el camino más corto entre dos nodos o puntos. A* es una versión popular y ampliamente utilizada de la búsqueda de rutas de primer nivel que es informada o guíada por heurística.

El algoritmo A\* se basa en el algoritmo de búsqueda de rutas de primer nivel, que es un algoritmo de búsqueda de rutas no informado. La búsqueda de rutas de primer nivel es un algoritmo de búsqueda de rutas que se utiliza para encontrar el camino más corto entre dos nodos o puntos. La búsqueda de rutas de primer nivel es un algoritmo de búsqueda de rutas no informado, lo que significa que no tiene información sobre la ubicación y la distribución de los nodos en el espacio de búsqueda, excepto su vecindad directa. La búsqueda de rutas de primer nivel es un algoritmo de búsqueda de rutas completa, lo que significa que siempre encontrará una solución si existe.

El algoritmo A* es una versión mejorada de la búsqueda de rutas de primer nivel. A* es un algoritmo de búsqueda de rutas informado, lo que significa que tiene información sobre la ubicación y la distribución de los nodos en el espacio de búsqueda, lo que se utiliza para guiar la búsqueda. A\* es un algoritmo de búsqueda de rutas completo, lo que significa que siempre encontrará una solución si existe.

El programa empieza por la importación del módulo de heapq la cual ayuda a manejar proporciona funciones para trabajar con colas de prioridad implementadas como montículos binarios.

Despues definimos un nodo el cual va a tener sus coordenadas del laberinto que se va a resolver, el padre del nodo y la distancia que tiene el nodo meta.Tambien se define `__lt__` para poder comparar los nodos y determinar cual es menor lo cual ayudará para el manejo de la cola de prioridad.

Despues definimos una función que nos va a ayudar a saber si el movimiento que se va a realizar es valido o no, esta función recibe como parametros el laberinto y las coordenadas del nodo.

Despues definimos una función que nos va a ayudar a calcular la distancia entre el nodo y la meta, esta función recibe como parametros el nodo y la meta. Esta función calcula la distancia Manhattan entre el nodo y la meta el cual es la suma de las diferencias absolutas de sus coordenadas.

Despues definimos una función que nos va a ayudar a reconstruir el camino que se va a seguir para llegar a la meta, esta función recibe como parametro el nodo actual. Esta función va a ir agregando los nodos al camino hasta llegar al nodo inicial. Como la función va a ir agregando los nodos del final al inicio, se debe invertir el camino para que quede en el orden correcto.

Despues definimos la función principal que es la que va a resolver el laberinto, esta función recibe como parametros el laberinto, el nodo inicial y el nodo meta. Esta función va a tener una cola de prioridad la cual va a tener el nodo inicial, un conjunto de nodos visitados y el nodo meta. Despues se agrega el nodo inicial a la cola de prioridad.
Mientras que haya algun elemento en la cola de prioridad open_set que es la lista abierta que usa el algoritmo hará lo siguiente:

1. Se saca el primer elemento de la cola de prioridad y se guarda en la variable current_node.
2. Se verifica si el nodo actual es igual al nodo meta, si es igual se llama a la función reconstruct_path y se le pasa el nodo actual.
3. Se agrega el nodo actual al conjunto de nodos visitados.
4. Se definen los vecinos del nodo actual.
5. Se recorren los vecinos del nodo actual.
6. Se verifica si el vecino no está en el conjunto de nodos visitados y si el movimiento que se va a realizar es valido, si se cumple se crea un nodo vecino y se le asigna el nodo actual como padre, despues se le asigna la distancia del nodo actual más 1 y la distancia del nodo vecino a la meta.
7. Se verifica si el nodo vecino no está en la cola de prioridad, si no está se agrega a la cola de prioridad.
8. Se retorna el camino que se debe seguir para llegar a la meta.

Despues se define el laberinto el cual en este caso es una matriz de 9x9, el nodo inicial y el nodo meta.

Despues se llama a la función a_star y se le pasan los parametros definidos anteriormente.

Despues se imprime el camino que se debe seguir para llegar a la meta.

# Reglas y Búsquedas: Espacio de Estados

## Generar el espacio de estados de los siguientes problemas

### Problema de las ranas

El juego consiste en pasar las 3 ranas verdes a la derecha y las 3 ranas marrones a la izquierda. Las ranas pueden saltar a una piedra vacía que tengan delante, o saltar por encima de otra rana si en medio de ambas hay una piedra vacía. Pulsa sobre la rana que quieres que salte.

V = Rana Verde
M = Rana Marrón
0 = Piedra Vacía

Estado inicial = [V,V,V,0,M,M,M]

Estado final = [M,M,M,0,V,V,V]

[V,V,V,0,M,M,M]

[V,V,V,M,0,M,M]

[V,V,0,M,V,M,M]

[V,0,V,M,V,M,M]

[V,M,V,0,V,M,M]

[V,M,V,M,V,0,M]

[V,M,V,M,V,M,0]

[V,M,V,M,0,M,V]

[V,M,0,M,V,M,V]

[0,M,V,M,V,M,V]

[M,0,V,M,V,M,V]

[M,M,V,0,V,M,V]

[M,M,V,M,V,0,V]

[M,M,V,M,0,V,V]

[M,M,0,M,V,V,V]

[M,M,M,0,V,V,V]

### Problema de los 3 misioneros y los 3 caníbales

Tres misioneros se perdieron explorando una jungla. Separados de sus compañeros, sin alimento y sin radio, solo sabían que para llegar a su destino debían ir siempre hacia adelante. Los tres misioneros se detuvieron frente a un río que les bloqueaba el paso, preguntándose que podían hacer. De repente, aparecieron tres caníbales llevando un bote, pues también el-los querían cruzar el río. Ya anteriormente se habían encontrado grupos de misioneros y caníbales, y cada uno respetaba a los otros, pero sin confiaren ellos.

Los caníbales se daban un festín con los misioneros cuando les superaban en número. Los tres caníbales deseaban ayudar a los misioneros a cruzar el río, pero su bote no podía llevar más de dos personas a la vez y los misioneros no querían que los caníbales les superaran en número.

¿Cómo puede resolverse el problema, sin que en ningún momento haya más caníbales que misioneros en cualquier orilla del río? recuerda que un misionero y un caníbal en una orilla del río más uno o dos caníbales en el bote al mismo lado, significa que los misioneros tendrán problemas.

canibales en izquierda [1,0,0,0,0,0]

misioneros en izquierda [0,1,0,0,0,0]

bote en izquierda [0,0,1,0,0,0]

bote en derecha [0,0,0,1,0,0]

canibales en derecha [0,0,0,0,1,0]

misioneros en derecha [0,0,0,0,0,1]

Estado inicial = [0,0,0,1,3,3]

Estado final = [3,3,1,0,0,0]

[0,0,0,1,3,3]

[1,1,1,0,2,2]

[1,0,0,1,2,3]

[3,0,1,0,0,3]

[2,0,0,1,1,3]

[2,2,1,0,1,1]

[1,1,0,1,2,2]

[1,3,1,0,2,0]

[0,3,0,1,3,0]

[2,3,1,0,1,0]

[1,3,0,1,2,0]

[3,3,1,0,0,0]

# Generación de Dataset

## Generar un dataset de rostros por lo menos 5 diferentes

El codigo para la obtencion del dataset es el siguiente el cual se obtiene de la camara del computador y se guarda en la carpeta DataSet en la carpeta p para las imagenes que contienen rostros y en la carpeta n para las imagenes que no contienen rostros. Las imagenes se guardan en escala de grises. Para guardar las imagenes se presiona la tecla a para las imagenes que contienen rostros con cubrebocas y la tecla s para las imagenes que no contienen rostros sin cubrebocas y fondos.

```python
import cv2 as cv

cap = cv.VideoCapture(0)

i=0

while True:
    ret, frame = cap.read()

    # frame =cv.rectangle(frame, (100, 100), (400, 400), (0, 255, 0), 3)
    frame2= frame[100:400, 100:400]
    frame3 = cv.cvtColor(frame2, cv.COLOR_BGR2GRAY)

    cv.imshow('frame', frame)
    cv.imshow('dataset', frame2)


    k = cv.waitKey(1)
    if k == ord('a'):
        i=i+1
        cv.imwrite('./DataSet/p/RostroCasa'+str(i)+'.jpg', frame3)
    if k == ord('s'):
        i=i+1
        cv.imwrite('./DataSet/n/NoRostroCasa'+str(i)+'.jpg', frame3)


    if k == ord('q'):
        break

cap.release()
cv.destroyAllWindows()
```

# Proyectos

## Proyecto 1: Juego Phaser

El juego consiste en que el jugador debe esquivar una bala proveniente de la derecha a la altura del suelo y otra bala proveniente de arriba. El jugador solo pude esquivarlas saltando y moviendose hacia la derecha. El juego termina cuando el jugador es golpeado por una bala. El juego se hizo con el motor de juegos Phaser.

```javascript
var w = 800;
var h = 400;
var jugador;
var fondo;

var bala,
  balaD = false,
  nave;

var nave2;
var bala2,
  balaD2 = false;

var salto;
var menu;
var collisionOcurred = false;

var velocidadBala;
var gravedadBala;
var despBala;
var despBala2;
var estatusAire;
var estatuSuelo;
var der;
var estatusDer;

var mov = 0;

var nnNetwork,
  nnEntrenamiento,
  nnSalida,
  datosEntrenamiento = [];
var modoAuto = false,
  eCompleto = false;

var juego = new Phaser.Game(w, h, Phaser.CANVAS, "", {
  preload: preload,
  create: create,
  update: update,
  render: render,
});

function preload() {
  // juego.load.image("fondo", "assets/game/fondo.jpg");
  juego.load.image("fondo", "assets/game/Orphan2.jpg");
  juego.load.spritesheet("mono", "assets/sprites/altair.png", 32, 48);
  juego.load.image("nave", "assets/game/ufo.png");
  juego.load.image("bala", "assets/sprites/purple_ball.png");
  juego.load.image("menu", "assets/game/menu.png");
}

function create() {
  juego.physics.startSystem(Phaser.Physics.ARCADE);
  juego.physics.arcade.gravity.y = 800;
  juego.time.desiredFps = 30;

  fondo = juego.add.tileSprite(0, 0, w, h, "fondo");
  fondo.tileScale.x = 0.5;
  fondo.tileScale.y = 0.5;
  nave = juego.add.sprite(w - 100, h - 70, "nave");
  bala = juego.add.sprite(w - 100, h, "bala");
  jugador = juego.add.sprite(50, h, "mono");
  nave2 = juego.add.sprite(jugador.position.x - 30, 0, "nave");
  bala2 = juego.add.sprite(nave2.position.x + 45, 50, "bala");

  juego.physics.enable(jugador);
  jugador.body.collideWorldBounds = true;
  var corre = jugador.animations.add("corre", [8, 9, 10, 11]);
  jugador.animations.play("corre", 10, true);

  juego.physics.enable(bala);
  juego.physics.enable(bala2);
  bala.body.collideWorldBounds = true;
  bala2.body.collideWorldBounds = true;

  pausaL = juego.add.text(w - 100, 20, "Pausa", {
    font: "20px Arial",
    fill: "#fff",
  });
  pausaL.inputEnabled = true;
  pausaL.events.onInputUp.add(pausa, self);
  juego.input.onDown.add(mPausa, self);

  salto = juego.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
  der = juego.input.keyboard.addKey(Phaser.Keyboard.RIGHT);

  nnNetwork = new synaptic.Architect.Perceptron(4, 6, 6, 2);
  nnEntrenamiento = new synaptic.Trainer(nnNetwork);
}

function enRedNeural() {
  nnEntrenamiento.train(datosEntrenamiento, {
    rate: 0.0001,
    iterations: 10000,
    shuffle: true,
  });
}

function datosDeEntrenamiento(param_entrada) {
  console.log("Entrada", param_entrada[0] + " " + param_entrada[1]);
  nnSalida = nnNetwork.activate(param_entrada);
}

function pausa() {
  juego.paused = true;
  menu = juego.add.sprite(w / 2, h / 2, "menu");
  menu.anchor.setTo(0.5, 0.5);
}

function mPausa(event) {
  if (juego.paused) {
    var menu_x1 = w / 2 - 270 / 2,
      menu_x2 = w / 2 + 270 / 2,
      menu_y1 = h / 2 - 180 / 2,
      menu_y2 = h / 2 + 180 / 2;

    var mouse_x = event.x,
      mouse_y = event.y;

    if (
      mouse_x > menu_x1 &&
      mouse_x < menu_x2 &&
      mouse_y > menu_y1 &&
      mouse_y < menu_y2
    ) {
      if (
        mouse_x >= menu_x1 &&
        mouse_x <= menu_x2 &&
        mouse_y >= menu_y1 &&
        mouse_y <= menu_y1 + 90
      ) {
        eCompleto = false;
        datosEntrenamiento = [];
        modoAuto = false;
      } else if (
        mouse_x >= menu_x1 &&
        mouse_x <= menu_x2 &&
        mouse_y >= menu_y1 + 90 &&
        mouse_y <= menu_y2
      ) {
        if (!eCompleto) {
          console.log(
            "",
            "Entrenamiento " + datosEntrenamiento.length + " valores"
          );
          enRedNeural();
          eCompleto = true;
        }
        modoAuto = true;
      }

      menu.destroy();
      resetsBalas();
      juego.paused = false;
      // console.log(datosDeEntrenamiento.length);
    }
  }
}

function resetsBalas() {
  jugador.body.velocity.x = 0;
  jugador.body.velocity.y = 0;
  jugador.position.x = 50;
  bala.body.velocity.x = 0;
  bala.position.x = w - 100;
  balaD = false;
  bala2.body.velocity.y = 0;
  bala2.position.y = 50;
  balaD2 = false;
}

function saltar() {
  jugador.body.velocity.y -= 270;
}

function moverDer() {
  jugador.body.position.x += 7;
}

function update() {
  fondo.tilePosition.x -= 1;

  juego.physics.arcade.collide([bala, bala2], jugador, colisionH, null, this);

  estatuSuelo = 1;
  // estatusAire = 0;
  estatusDer = 0;

  if (!jugador.body.onFloor()) {
    estatuSuelo = 0;
    // estatusAire = 1;
  }

  despBala = Math.floor(jugador.position.x - bala.position.x);

  despBala2 = Math.floor(jugador.position.y - bala2.position.y);

  if (modoAuto == false && salto.isDown && jugador.body.onFloor()) {
    saltar();
    estatuSuelo = 0;
  }

  if (modoAuto == false && der.isDown) {
    moverDer();
    estatusDer = 1;
  }

  if (modoAuto == true) {
    datosDeEntrenamiento([despBala, velocidadBala, despBala2, gravedadBala]);
    console.log("nnSalida", nnSalida[0] + " " + nnSalida[1]);
    if (nnSalida[0] <= 0.5 && jugador.body.onFloor()) {
      saltar();
    }
    if (nnSalida[1] >= 0.5) {
      moverDer();
    }
  }

  if (balaD == false) {
    disparo();
  }

  if (balaD2 == false) {
    disparo2();
  }

  if (bala.position.x <= 0) {
    resetsBalas();
  }

  if (modoAuto == false) {
    datosEntrenamiento.push({
      input: [despBala, velocidadBala, despBala2, gravedadBala],
      output: [estatuSuelo, estatusDer],
    });

    console.log(
      despBala +
        " " +
        velocidadBala +
        " " +
        despBala2 +
        " " +
        gravedadBala +
        " " +
        estatuSuelo +
        " " +
        estatusDer
    );
  }
}

function disparo() {
  velocidadBala = -1 * velocidadRandom(250, 500);
  bala.body.velocity.y = 0;
  bala.body.velocity.x = velocidadBala;
  balaD = true;
}

function disparo2() {
  gravedadBala = velocidadRandom(50, 100);
  bala2.body.velocity.y = gravedadBala;
  balaD2 = true;
}

function colisionH() {
  pausa();
}

function velocidadRandom(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function render() {}
```

Es bastante codigo por analizar pero realmente solo nos inetersa algunos datos de aqui. Primero que nada se define el tamaño del juego y se cargan las imagenes que se van a utilizar. Despues se crean los objetos que se van a utilizar en el juego como el fondo, el jugador, las balas, la nave y el menu de pausa. Despues se define la funcion de pausa y la funcion de moverse a la derecha. Despues se define la funcion de saltar la cual se activa cuando se presiona la barra espaciadora. Despues se define la funcion de disparo la cual se activa cuando la bala llega al final del juego. Despues se define la funcion de disparo2 la cual se activa cuando la bala2 llega al final del juego. Despues se define la funcion de colisionH la cual se activa cuando el jugador es golpeado por una bala. Despues se define la funcion de velocidadRandom la cual nos ayuda a generar un numero aleatorio entre un rango de numeros. Despues se define la funcion de update la cual se ejecuta cada vez que se actualiza el juego. Dentro de esta funcion se actualiza la posicion del fondo, se verifica si el jugador esta en el suelo o en el aire, se verifica si el jugador se mueve a la derecha, se verifica si el jugador salta, se verifica si el jugador esta en modo automatico, se verifica si la bala llego al final del juego, se verifica si la bala2 llego al final del juego y se verifica si el jugador es golpeado por una bala. Despues se define la funcion de render la cual se ejecuta cada vez que se renderiza el juego.

Cuando el juego esta siendo controlado por el jugador se van guardando los datos de entrenamiento en un arreglo el cual se va a utilizar para entrenar la red neuronal, sus entradas son la distancia entre el jugador y la bala, la velocidad de la bala, la distancia entre el jugador y la bala2 y la gravedad de la bala2. Sus salidas son si el jugador esta en el suelo o en el aire y si el jugador se mueve a la derecha o no. Esto solo se maneja con 2 salidas, estatusSuelo y estatusDer, las cuales son 1 si el jugador esta en el suelo y 0 si el jugador esta en el aire y 1 si el jugador se mueve a la derecha y 0 si el jugador no se mueve a la derecha. Cuando el jugador esta en modo automatico se activa la red neuronal la cual recibe como entradas la distancia entre el jugador y la bala, la velocidad de la bala, la distancia entre el jugador y la bala2 y la gravedad de la bala2. Sus salidas son si el jugador esta en el suelo o en el aire y si el jugador se mueve a la derecha o no. La red neuronal se entrena con los datos de entrenamiento y se activa la red neuronal para que el jugador salte o se mueva a la derecha dependiendo de las salidas de la red neuronal. El jugador salta cuando la salida de estatusSuelo es menor o igual a 0.5 y se mueve a la derecha cuando la salida de estatusDer es mayor o igual a 0.5.

La definicion de la red neuronal es la siguiente:

```javascript
nnNetwork = new synaptic.Architect.Perceptron(4, 6, 6, 2);
nnEntrenamiento = new synaptic.Trainer(nnNetwork);
```

La red neuronal tiene 4 entradas, 6 neuronas en una capa oculta, 6 neuronas en otra capa oculta y 2 salidas.

La funcion de entrenamiento de la red neuronal es la siguiente:

```javascript
nnEntrenamiento.train(datosEntrenamiento, {
  rate: 0.0001,
  iterations: 10000,
  shuffle: true,
});
```

La red neuronal se entrena con los datos de entrenamiento, con una tasa de aprendizaje de 0.0001, con 10000 iteraciones y con los datos de entrenamiento desordenados.

La funcion de activacion de la red neuronal es la siguiente:

```javascript
nnSalida = nnNetwork.activate(param_entrada);
```

La red neuronal se activa con las entradas de la distancia entre el jugador y la bala, la velocidad de la bala, la distancia entre el jugador y la bala2 y la gravedad de la bala2. La salida de la red neuronal se guarda en nnSalida la cual es un arreglo de 2 posiciones para luego ser utilizada para saltar y moverse a la derecha.

## Proyecto 2: Detector de Rostros con Cubrebocas usando OpenCV y Haar Cascade

Una vez obtenido el dataset se utilizó la herramienta Cascade-Trainer-GUI con los siguientes parametros:

- Positivas: 85%
- Negativas: 4,255
- Stages: 20
- Memoria: 12288

  El resto se dejó intacto. Una vez obtenido el archivo .xml se utilizó el siguiente codigo para la deteccion de rostros con cubrebocas.

```python
import cv2 as cv

rostro = cv.CascadeClassifier('cascade.xml')
cap = cv.VideoCapture(0)

if not cap.isOpened():
    print("No se puede abrir la camara")
    exit()

i=0

while True:
    ret, frame = cap.read()
    i=i+1
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    rostros = rostro.detectMultiScale(gray, scaleFactor= 1.3, minNeighbors= 15, minSize=(60, 60))
    for(x,y,w,h) in rostros:
        frame =cv.rectangle(frame, (x, y), (x+w, y+h), (0, 255, 0), 5)
        # frame =cv.rectangle(frame, (x+30, y+40), (x+w-30, y+h-100), (255, 0, 0), 3)
        # w1=int(w/2)
        # h1=int(h/2)
        # frame=cv.circle(frame, (x+w1, y+h1+10), 25, (0, 0, 255), 3 )
        # frame =cv.rectangle(frame, (x+30, y+h-20), (x+w-30, y+h-60), (0, 255, 0), 3)

    if not ret:
        print("No se puede")
        break

    cv.imshow('rostros', frame)

    if cv.waitKey(1) == ord('q'):
        break

cap.release()
cv.destroyAllWindows()
```

Aqui los datos que se usan para variar las configuraciones son scaleFactor, minNeighbors y minSize. scaleFactor es el factor de escala que se usa para crear una piramide de imagenes. minNeighbors es el numero de vecinos que cada rectangulo candidato debe retener. minSize es el tamaño minimo del objeto. Estos datos se pueden variar para obtener mejores resultados

## Proyecto 3: CNN para Clasificar Imagenes de Flores

para la obtencion del dataset en esta parte fue un poco diferente, pues se grabó videos de las flores y se extrajeron los frames de los videos para obtener las imagenes. Por cada frame se rotó desde -15 hasta 15 grados para lograr obtener un dataset mayor. El codigo para la obtencion del dataset es el siguiente:

```python
import cv2
import os
import numpy as np

input_video = "RosaDesierto.mp4"

flor = "RosaDesierto"

output_folder = f"datasetFlowers/{flor}/"

os.makedirs(output_folder, exist_ok=True)

cap = cv2.VideoCapture(input_video)

if not cap.isOpened():
    print("Error al abrir el video")
    exit()

frame_count = 0
# 15500 es el número de fotogramas del video de bromelia 1

while True:
    ret, frame = cap.read()

    if not ret:
        break

    new_width = 120
    new_height = 120
    frame = cv2.resize(frame, (new_width, new_height), interpolation=cv2.INTER_CUBIC)

    for angle in range(-15, 16):
        rotated_frame = np.array(frame)
        M = cv2.getRotationMatrix2D((new_width / 2, new_height / 2), angle, 1)
        rotated_frame = cv2.warpAffine(rotated_frame, M, (new_width, new_height))

        frame_filename = os.path.join(output_folder, f"{flor}_{frame_count:03d}_rotated_{angle:03d}.jpg")
        cv2.imwrite(frame_filename, rotated_frame)

        frame_count += 1

cap.release()

print(
    f"Se han extraído {frame_count} fotogramas de la flor {flor} y se han guardado en la carpeta {output_folder}."
)
```

Por otro lado tambien se descaargó datasets de internet entonces se usó el siguiente codigo para rotar las imagenes de todas las carpetas y guardarlas en otra carpeta ya rotadas y redimensionadas.

```python
import cv2
import os
import numpy as np

def procesar_carpetas(carpeta_antigua, carpeta_salida):
    for subcarpeta in os.listdir(carpeta_antigua):
        subcarpeta_path = os.path.join(carpeta_antigua, subcarpeta)

        if os.path.isdir(subcarpeta_path):
            carpeta_salida_actual = os.path.join(carpeta_salida, subcarpeta)
            os.makedirs(carpeta_salida_actual, exist_ok=True)

            print(f"Procesando subcarpeta: {subcarpeta}")

            for archivo in os.listdir(subcarpeta_path):
                archivo_path = os.path.join(subcarpeta_path, archivo)

                if os.path.isfile(archivo_path) and archivo.lower().endswith(('.jpg', '.jpeg')):
                    frame = cv2.imread(archivo_path)

                    new_width = 120
                    new_height = 120
                    frame = cv2.resize(frame, (new_width, new_height), interpolation=cv2.INTER_CUBIC)

                    for angle in range(-15, 16):
                        rotated_frame = np.array(frame)
                        M = cv2.getRotationMatrix2D((new_width / 2, new_height / 2), angle, 1)
                        rotated_frame = cv2.warpAffine(rotated_frame, M, (new_width, new_height))

                        frame_filename = os.path.join(carpeta_salida_actual, f"{archivo[:-4]}_rotated_{angle:03d}.jpg")
                        cv2.imwrite(frame_filename, rotated_frame)

carpeta_antigua = "flowers"
carpeta_salida = "datasetFlowers"
procesar_carpetas(carpeta_antigua, carpeta_salida)
```

Puntos importantes a analizar ya con el dataset obtenido:

- El tamaño de las imagenes es de 120x120
- Las imagenes son a color por lo que la red acepta 3 canales para los colores
- Las imagenes son de 5 tipos de flores diferentes:
  - 0 Daisy
  - 1 Dandelion
  - 2 Roses
  - 3 Sunflower
  - 4 TigerLily
- El formato de las imagenes es jpg, ya que con png no se podia leer el dataset correctamente debido a la transaparencia de las imagenes y todas eran negras al momento de leerlas

Las configuraciones de la red neuronal son las siguientes:

- INIT_LR (Learning Rate Inicial): 1e-3 (0.001): Es la tasa de aprendizaje inicial. Es un valor que se usa para actualizar los pesos de la red neuronal con el error de la red neuronal. Si el valor es muy pequeño, el entrenamiento será muy lento y si el valor es muy grande, el entrenamiento será muy rápido y la red neuronal no aprenderá correctamente.
- EPOCHS: 30: Si el número de épocas es demasiado pequeño, la red podría no aprender patrones complejos en los datos. Por otro lado, si el número de épocas es excesivamente grande, puede conducir a un entrenamiento lento y, en casos extremos, a un sobreajuste donde la red memoriza el conjunto de datos en lugar de generalizar a nuevos datos. En la elección del número de épocas, es crucial encontrar un equilibrio para lograr un aprendizaje efectivo sin exceso de entrenamiento.
- BATCH_SIZE (Batch Size): 64: Indica cuántas imágenes se toman a la vez durante el entrenamiento. Utilizar lotes más grandes puede acelerar el entrenamiento, pero requiere más memoria.
- 1 Bloque de Convolución: 32 filtros de 3x3, activación Lineal, entrada de 120x120x3 y relleno de 1: El bloque de convolución es la parte de la red neuronal que se encarga de extraer las características de las imágenes. El bloque de convolución se compone de filtros que se encargan de extraer las características de las imágenes. Los filtros se aplican a las imágenes y se obtienen mapas de características. Los filtros se aplican a las imágenes con una ventana de 3x3 y se obtienen 32 mapas de características. La activación lineal se encarga de que la salida de los filtros sea positiva. La entrada de los filtros es de 120x120x3 que es el tamaño de las imágenes y el relleno de 1 es para que las imagenes no se reduzcan de tamaño.

Los resultados de la red neuronal son los siguientes:

1. Pérdida (Loss) y Precisión (Accuracy) en el Conjunto de Entrenamiento:
   Pérdida final en entrenamiento: 0.2925

   Precisión final en entrenamiento: 90.08%

2. Pérdida (Loss) y Precisión (Accuracy) en el Conjunto de Validación:
   Pérdida final en validación: 0.1928

   Precisión final en validación: 94.54%

La diferencia entre la precisión de entrenamiento y la precisión de validación no es excesiva, lo cual es un buen indicador de generalización.
La pérdida y precisión en ambos conjuntos parecen evolucionar de manera coherente durante el entrenamiento, sin señales de sobreajuste o subajuste significativos.
